package services

import (
	"database/sql"
	"github.com/labstack/gommon/log"
	"pvz/internal/logger"
	"pvz/internal/models"
	"pvz/internal/models/pvz"
	"pvz/internal/models/reception"
	"pvz/internal/repositories"
	"pvz/pkg/errors"
)

type PvzService interface {
	Create(req pvz.CreateRequest) (pvz.CreateResponse, error)
	DeleteLastProduct(pvzId string) (pvz.DeleteLastProductResponse, error)
	CLoseLastReception(pvzId string) (pvz.CloseLastProductResponse, error)
	ListWithFilterDate(req pvz.ListRequest) ([]pvz.ListResponse, error)
}

type pvzServiceImpl struct {
	pvzRepo       repositories.PvzRepository
	productRepo   repositories.ProductRepository
	receptionRepo repositories.ReceptionRepository
	conn          *sql.DB
}

func NewPvzService(pvzRepo repositories.PvzRepository, productRepo repositories.ProductRepository, receptionRepo repositories.ReceptionRepository, conn *sql.DB) PvzService {
	return &pvzServiceImpl{
		pvzRepo:       pvzRepo,
		productRepo:   productRepo,
		receptionRepo: receptionRepo,
		conn:          conn,
	}
}
func (ps *pvzServiceImpl) Create(req pvz.CreateRequest) (pvz.CreateResponse, error) {
	log := logger.Log.With("city", req.City)
	if req.Id != nil {
		log = log.With("pvzId", *req.Id)
	}
	log.Info("starting Create Pvz")

	tx, err := ps.conn.Begin()
	if err != nil {
		log.Error("failed to begin transaction", "err", err)
		return pvz.CreateResponse{}, errors.NewInternalError()
	}
	defer tx.Rollback()

	if req.Id == nil {
		reqId := ""
		req.Id = &reqId
		log.Info("no id provided, using autogenerated id")
	} else {
		pvzWithId, err := ps.pvzRepo.GetById(tx, *req.Id)
		if err != nil {
			log.Error("failed to check existing pvz", "err", err)
			return pvz.CreateResponse{}, errors.NewInternalError()
		}
		if pvzWithId != nil {
			log.Warn("pvz with given id already exists")
			return pvz.CreateResponse{}, errors.NewObjectAlreadyExists("pvz", "id", *req.Id)
		}
	}

	newPvz, err := ps.pvzRepo.Create(tx, req)
	if err != nil {
		log.Error("failed to create pvz", "err", err)
		return pvz.CreateResponse{}, err
	}

	if err := tx.Commit(); err != nil {
		log.Error("failed to commit transaction", "err", err)
		return pvz.CreateResponse{}, errors.NewInternalError()
	}

	log.Info("pvz successfully created", "pvzId", newPvz.Id)

	return pvz.CreateResponse{
		Id:               newPvz.Id,
		RegistrationDate: newPvz.RegistrationDate,
		City:             req.City,
	}, nil
}

func (ps *pvzServiceImpl) DeleteLastProduct(pvzId string) (pvz.DeleteLastProductResponse, error) {
	log := logger.Log.With("pvzId", pvzId)
	log.Info("starting DeleteLastProduct")

	tx, err := ps.conn.Begin()
	if err != nil {
		log.Error("failed to begin transaction", "err", err)
		return pvz.DeleteLastProductResponse{}, err
	}
	defer tx.Rollback()

	if _, err = ps.getPvzOrErr(tx, pvzId); err != nil {
		log.Error("failed to get pvz", "err", err)
		return pvz.DeleteLastProductResponse{}, err
	}

	rec, err := ps.getReceptionOrErr(tx, pvzId)
	if err != nil {
		log.Error("failed to get reception", "err", err)
		return pvz.DeleteLastProductResponse{}, err
	}

	pr, err := ps.productRepo.DeleteLast(tx, rec.Id)
	if err != nil {
		log.Error("failed to delete last product", "err", err)
		return pvz.DeleteLastProductResponse{}, errors.NewInternalError()
	}
	if pr == nil {
		log.Warn("no products found to delete")
		return pvz.DeleteLastProductResponse{}, errors.NewObjectHasNotSubObjects("reception", "product")
	}

	if err := tx.Commit(); err != nil {
		log.Error("failed to commit transaction", "err", err)
		return pvz.DeleteLastProductResponse{}, errors.NewInternalError()
	}

	log.Info("product successfully deleted", "productId", pr.Id)

	return pvz.DeleteLastProductResponse{
		Id: pr.Id,
	}, nil
}

func (ps *pvzServiceImpl) CLoseLastReception(pvzId string) (pvz.CloseLastProductResponse, error) {
	log := logger.Log.With("pvzId", pvzId)
	log.Info("starting CloseLastReception")

	tx, err := ps.conn.Begin()
	if err != nil {
		log.Error("failed to begin transaction", "err", err)
		return pvz.CloseLastProductResponse{}, err
	}
	defer tx.Rollback()

	if _, err = ps.getPvzOrErr(tx, pvzId); err != nil {
		log.Error("failed to get pvz", "err", err)
		return pvz.CloseLastProductResponse{}, err
	}

	_, err = ps.getReceptionOrErr(tx, pvzId)
	if err != nil {
		log.Error("failed to get in-progress reception", "err", err)
		return pvz.CloseLastProductResponse{}, err
	}

	closeRec, err := ps.receptionRepo.SetStatus(tx, reception.CloseStatus, pvzId)
	if err != nil {
		log.Error("failed to close reception", "err", err)
		return pvz.CloseLastProductResponse{}, errors.NewInternalError()
	}
	if closeRec == nil {
		log.Warn("no in-progress reception to close")
		return pvz.CloseLastProductResponse{}, errors.NewObjectHasNotSubObjects("pvz", "reception")
	}

	if err := tx.Commit(); err != nil {
		log.Error("failed to commit transaction", "err", err)
		return pvz.CloseLastProductResponse{}, errors.NewInternalError()
	}

	log.Info("reception successfully closed", "receptionId", closeRec.Id)

	return pvz.CloseLastProductResponse{
		Id:       closeRec.Id,
		DateTime: closeRec.DateTime,
		PvzId:    pvzId,
		Status:   closeRec.Status,
	}, nil
}

func (ps *pvzServiceImpl) ListWithFilterDate(req pvz.ListRequest) ([]pvz.ListResponse, error) {
	log := logger.Log.With(
		"startDate", req.StartDate,
		"endDate", *req.EndDate,
		"limit", req.Limit,
		"page", req.Page,
	)
	log.Info("starting ListWithFilterDate")

	if req.StartDate.After(*req.EndDate) {
		log.Warn("start date is after end date")
		return nil, errors.NewStartDateAfterEndDate()
	}

	offset := (req.Page - 1) * req.Limit

	respRows, err := ps.pvzRepo.ListWithFilterDate(ps.conn, req, offset)
	if err != nil {
		log.Error("failed to fetch pvz list", "err", err)
		return nil, errors.NewInternalError()
	}
	if respRows == nil {
		log.Warn("no pvzs found for given date range")
		return nil, errors.NewObjectNotFound("pvzs")
	}

	log.Info("successfully fetched pvz list", "rows", len(respRows))

	pvzRecGroup := map[models.PvzReception]*pvz.ListResponse{}

	for _, row := range respRows {
		pr := models.PvzReception{PvzId: row.PvzId, ReceptionId: row.ReceptionId}
		resp, exists := pvzRecGroup[pr]
		if !exists {
			resp = &pvz.ListResponse{
				Pvz: pvz.Pvz{
					Id:               row.PvzId,
					RegistrationDate: row.PvzRegDate,
					City:             row.PvzCity,
				},
				Receptions: []pvz.ReceptionProducts{
					{
						Reception: pvz.Reception{
							Id:       row.ReceptionId,
							DateTime: row.ReceptionDate,
							PvzId:    row.PvzId,
							Status:   row.ReceptionStatus,
						},
						Products: []pvz.Product{},
					},
				},
			}
			pvzRecGroup[pr] = resp
		}

		if row.ProductId.Valid {
			receptionIdx := len(resp.Receptions) - 1
			resp.Receptions[receptionIdx].Products = append(
				resp.Receptions[receptionIdx].Products,
				pvz.Product{
					Id:          row.ProductId.String,
					DateTime:    row.ProductDate.Time,
					Type:        row.ProductType.String,
					ReceptionId: row.ReceptionId,
				},
			)
		}
	}

	result := make([]pvz.ListResponse, 0, len(pvzRecGroup))
	for _, v := range pvzRecGroup {
		result = append(result, *v)
	}
	return result, nil
}

func (ps *pvzServiceImpl) getPvzOrErr(tx *sql.Tx, id string) (*models.Pvz, error) {
	log.Info("starting getPvzOrErr")

	p, err := ps.pvzRepo.GetById(tx, id)
	if err != nil {
		log.Error("failed to fetch pvz", "err", err)
		return nil, errors.NewInternalError()
	}
	if p == nil {
		log.Warn("pvz not found")
		return nil, errors.NewObjectNotFound("pvz")
	}

	log.Info("pvz found", "pvzId", p.Id)
	return p, nil
}

func (ps *pvzServiceImpl) getReceptionOrErr(tx *sql.Tx, pvzId string) (*models.Reception, error) {
	log.Info("starting getReceptionOrErr")
	rec, err := ps.receptionRepo.GetByPvzId(tx, pvzId)
	if err != nil {
		log.Error("failed to fetch reception", "err", err)
		return nil, errors.NewInternalError()
	}
	if rec == nil {
		log.Warn("reception not found for pvz")
		return nil, errors.NewObjectHasNotSubObjects("pvz", "reception")
	}
	if rec.Status != reception.InProgressStatus {
		log.Warn("reception is not in-progress")
		return nil, errors.NewNoInProgressReception()
	}

	log.Info("reception found", "receptionId", rec.Id)
	return rec, nil
}
